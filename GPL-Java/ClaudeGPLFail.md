

Human: I'd like to implement a configurable graph application.The features belong to the graph domain and are named as follows: Directed, Undirected, Weighted, Unweighted, DFS, BFS, Number, Connected, StronglyConnected, Cycle, MSTPrim, MSTKruskal, Shortest.A graph is either Directed or Undirected. Edges can be Weighted with non-negative numbers or Unweighted. Every graph application requires at most one search algorithm: breadth-first search (BFS) or depth-first search (DFS); and one or more of the following algorithms:*   Vertex Numbering (aka Number feature): Assigns a unique number to each vertex as a    result of a graph traversal.*   Connected Components (aka Connected feature): Computes the connected components    of an undirected graph, which are equivalence classes under the reachable-fromrelation. For every pair of vertices x and y in an equivalence class, there is a pathfrom x to y.*   Strongly Connected Components (aka StronglyConnected feature): Computes the    strongly connected components of a directed graph, which are equivalence classesunder the reachable-from relation. A vertex y is reachable form vertex x if there isa path from x to y.*   Cycle Checking (aka Cycle feature): Determines if there are cycles in a graph. A cycle in    directed graphs must have at least 2 edges, while in undirected graphs it must haveat least 3 edges.*   Minimum Spanning Tree (aka MSTPrim or MSTKruskal features): Computes a Minimum    Spanning Tree (MST), which contains all the vertices in the graph such that thesum of the weights of the edges in the tree is minimal. We include both algorithmsbecause they present distinct and interesting performance and design issues.*   Single-Source Shortest Path (aka Shortest feature): Computes the shortest path from a    source vertex to all other vertices.Please implement such a configurable application in Java

Assistant:  Here is a possible implementation of the configurable graph application in Java:```javapublic class GraphApp {    private Graph graph;    private boolean directed;    private boolean weighted;        private enum Feature {        DFS, BFS, NUMBER, CONNECTED, STRONGLY_CONNECTED,         CYCLE, MST_PRIM, MST_KRUSKAL, SHORTEST_PATH    }        private Set<Feature> features = new HashSet<>();        public GraphApp(boolean directed, boolean weighted) {        this.directed = directed;        this.weighted = weighted;        graph = directed ? new Digraph() : new Undigraph();    }        public void addFeature(Feature feature) {        features.add(feature);    }        public void addEdge(int v1, int v2, int weight) {        graph.addEdge(v1, v2, weight);    }        public void compute() {        if (features.contains(Feature.DFS) || features.contains(Feature.BFS)) {            // Run DFS or BFS traversal to enable vertex numbering         }        if (features.contains(Feature.NUMBER)) {            // Assign numbers to vertices        }        // Compute other selected features...    }}```The GraphApp class has the following attributes:- graph: The underlying graph data structure (Digraph for directed, Undigraph for undirected)- directed: A boolean indicating if the graph is directed or undirected - weighted: A boolean indicating if the graph is weighted or unweighted- features: A set of selected features to computeThe methods are:- addFeature(Feature): Adds a feature to compute - addEdge(v1, v2, weight): Adds an edge to the graph- compute(): Computes the selected features on the graphThis is a basic structure for the configurable graph application. The actual graph algorithms for each feature would need to be implemented. Let me know if you have any other questions!
